\chapter{Introduction to Algorithmic Design}
\pagenumbering{arabic} 
\section{Computation and Computerisation}

Today, in almost all engineering and architectural fields, computers are used heavily and almost exclusively for any type of work. Some of the utilisation of computers in architecture such as 3D NURBS or Mesh modelling programs, or any mouse manipulated 3D forms programmes, are often thought to be computational. Although they essentially use numerical computation to display or `translate' \cite{terzidis06} different forms, ultimately it is the user who willingly manipulates the models.  This is a confusion between computation and computerisation. 

\paragraph{Computerisation}could be defined as using the computer as a tool instead of traditional tools or media. One could use ink and paper to write a letter, or use a word processor instead. Using a word processor, the presentation of the document is improved, and the work is done faster, but the content would not change on account of this tool swap. The same notion basically applies to CAD programmes, which are merely tools to draw shapes in a manner which essentially replaces pencil and paper; in both cases the user is in complete control of the outcome.

\paragraph{Computation}on the other hand produces that which is not under the complete control of the user, and is to some extent unpredictable. The input in this case is not the final product. This input constraints the process towards a roughly imagined product; but does not completely define it. This is due to the fact that computation is used in areas where humans are very limited; such as calculation and processing of large numbers. Computation is utilised in producing objects of high complexity, or in large numbers with a wide spectrum of variation that would make it impossible for the user to manually model.

To reiterate the above stated; the product of computation --- even though the algorithms that govern it and the input it needs are a product of the human mind --- is not solely a product of the human mind, but a product of a parallel logic.

\section{Parallel Logic}

\label{ParallelLogic}
Computers solve problems in a finite number of steps; either deterministically, or stochastically\footnote{Stochastic: Involving a random variable \cite{merriam03}}. The problems it solves can be a specific problem or an exploration of the unknown. The logic it uses, was designed by people, which might imply that computer logic is a subset of human logic; the fact is: it is not.

The way computers rationalise is different from how people think; it is in fact inconceivable by humans, the same way a human's rationalisation is virtually impossible for a computer to emulate.  This is due to the fact that computers can process enormous amounts of abstract data and numbers--- a good example is the `Brute force' solution search technique which processes `all' possible solutions of a problem, which could be thousands or millions of solutions. On the other hand, it cannot perceive intuition, or personal preference; things that are unique to the human's mind and require emotion and subconscious reactions.

In order to programme a computer to solve a problem, the user must create was is called an \emph{algorithm}.

\paragraph{Algorithms,}or procedures, are a description of steps to accomplish a specific task, which ``\emph{allow abstraction and encapsulation of complexity and re-usability}'' \cite{hernandez06}. In abstraction; procedures have three parts:
\begin{enumerate}
  \item The name of the procedure, which is the handle by which the procedure is called.
  \item The arguments, which are the parameters used within the procedure. These are similar to ingredients in a recipe.
  \item The description of the procedure, which is the recipe itself. Within this process the user inputs values into parameters\footnote{Parameters are a series of arguments which take up values in a function, and are also the placeholder of variable value.}, the procedure makes calculations according to the description of the procedures and outputs the result to the user. The calculation part is usually hidden from the user, which is called encapsulation.
\end{enumerate}

\section{Geometric Modelling and Design as Algorithms}
\label{sec:GeoModel}
The question of whether a paradigm of logic such as algorithms is capable of producing architectural design can be answered by starting at the fact that architectural design is ultimately composed of interrelated geometrical objects.

The way geometry is defined is very specific to the different types of geometry being defined. A point is defined by three variables of space, a line is defined by two points each holding three values in space\ldots etc, with the addition of more complex modelling techniques such as Boolean operations, more complex geometries can be created. This nature of geometrical definitions can be translated into procedures, each having a different set of encapsulated parameters. Therefore, geometric modelling is a parametric procedure. \cite{hernandez06}

\begin{figure}[htbp]
\flushleft
\begin{tikzpicture}[scale=3]
\draw [very thick] (0,0) --(0,2) --(2,2) --(2,0) --(0,0);
\draw (1,1) --(1,3) --(3,3) --(3,1) --(1,1);
\draw [->,dashed,thick,blue] (0,0) --(1,1);
\draw [->,dashed,thick,blue] (0,2) --(1,3);
\draw [->,dashed,thick,blue] (2,2) --(3,3);
\draw [->,dashed,thick,blue] (2,0) --(3,1);
\draw [thick,blue,fill=red](0,0) circle [radius=0.03];
\node [below] at (0,0) {\tiny Procedure Handle: Point(A)};
\node [below] at (0,-0.1) {\tiny Parameters: x,y,z};
\node [below] at (0,-0.2) {\tiny Values: 0,0,0};
\node [below] at (0,2) {\tiny \emph{(x=0,y=2,z=0)}};
\node [below] at (2,2) {\tiny \emph{(x=2,y=2,z=0)}};
\node [below] at (2,0) {\tiny \emph{(x=2,y=0,z=0)}};
\node at (1,1.3) {\tiny Procedure Handle: Square(A)};
\node at (1,1.2) {\tiny Parameters: Point(A),(B),(C),(D)};
\node at (2.4,0.6) [rotate=45] {\tiny Procedure Handle:};
\node at (2.6,0.4) [rotate=45] {\tiny ExtrudedBox(A)};
\end{tikzpicture}
\centering
\vspace{5mm}
\caption[Procedures and Parameters in Algorithmic Modelling]{Procedures and Parameters in Algorithmic Modelling. {\footnotesize Point procedure with three parameters, a square procedure with points as parameters, and a cube extrusion procedure with the square as a parameter}}
\label{SqrAnalysis}
\end{figure}

In terms of pure geometry; a cube for example can be defined by extruding a square along it's perpendicular axe, which makes the square in this case a parameter of the extrusion procedure (Figure \ref{SqrAnalysis}).

Architectural design can also be defined by procedures, when it is broken down into a step-by-step process, which would contain arguments (parameters) that alter the design with variable values. \label{SequentialAlgorithms}

Algorithmic design can be summarised as: ``\emph{A procedure carrying instructions in a systematic order where all geometrical components that represent a design are parameterised}''\cite{hernandez06}. Algorithmic design can also be defined as \emph{rule-based} design; consisting of a solid set of consecutive instructions that govern an action to produce a desired outcome, while noting that in this particular case; the outcome does not necessarily match the intent.

\subsection{Building Elements as Smart Objects}

The geometrical example shown above may imply that buildings as \emph{abstract} geometrical objects only can be defined and programmed into a computer; however, this serves only as a basis to a much more complex system of definition of buildings to the computer. 

The modelling of building and its architectural elements has reached a much higher level of complexity, where the elements are defined by detailed parameters that correspond to their function, construction method, unique geometry\ldots{}etc. An example of these complex modelling systems is \emph{Building Information Modelling}, which would take building elements and break them down into categories (structural, architectural, mechanical\ldots{}etc.) and then into specific groups of similar attributes (windows, doors, walls, floors\ldots{}etc.) which would serve as parameters that can easily be programmed into an algorithm, and therefore serve as a much more sophisticated platform for algorithmic design.

\section{Generative Systems Taxonomy}

\label{GenSysTax}
``Generative systems build on top of one core component; algorithms. They add different layers of properties devising distinct categories. These layers may also overlap highlighting finer classes within a category. In other words, every generative system is an algorithmic system.'' \cite{khaldi04} (Refer to figure \ref{fig:Taxonomy})

As stated in the previous section; algorithmic systems may run sequentially (Page \pageref{SequentialAlgorithms}), however, they also may run in parallel or in a random fashion. Parallel algorithms deal with elements simultaneously and separately without affecting each other. Sequential algorithms deal with elements one by one such that a predecessor affects it's successor. Random Algorithms do not follow any specific order.

Other systems are associative (having relationships); linking parameters to each other, or an action to a series of actions\ldots etc. Associations are usually viewed as constraints for they impose definitions of how a system behaves. 

A special type of associative algorithms is the hierarchical system. In this type elements are classified as ``Parents'' and ``Children''; where parents are higher level elements and children are lower level elements. Hierarchical systems allow for one direction association from top to bottom where parents drive children and not the other way around.

Regardless of the classification above, some systems may be context-sensitive, or ``\emph{rule-based}''. These are expressed in ``\emph{if\ldots then}`` statements. Rule-based algorithms work only if a particular condition (rule) is met. There are many types of rules such as: interpretation, transformation, deformation, replacement\ldots etc.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{./Images/1-Taxonomy}
	\caption[Taxonomy of Generative Systems]{Taxonomy and interrelations of generative systems \cite{khaldi04}}
	\label{fig:Taxonomy}
\end{figure}

\clearpage
\section{Chapter Conclusions}

The main points discussed in this chapter can be summarised as follows:
\vspace{-0.3cm}
\begin{enumerate}
	\item Traditional draughting programmes using CAD technology are a form of \emph{computerisation} of manual work. This thesis focuses on a different type of utilisation of computers in architecture, which is \emph{computation}.
	\item The use of computation produces designs which are a product \emph{parallel logic}, meaning that computers analyse and solve problems in a way that is very different from how humans do.
	\item To use computation in the architectural design process, the tool which is used and is the main subject of this thesis is called \emph{Algorithm}.
	\item Algorithms require that 3D models of buildings are created in a certain way where it's elements are \emph{Parametric}. This is possible through the use of Parametric CAD programmes or Building Information Modelling programmes.
	\item Algorithms in general have many uses in engineering problems and are categorised according to their \emph{Search Method}
\end{enumerate}
