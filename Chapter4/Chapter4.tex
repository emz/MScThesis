\chapter{Application and Case Studies}

In this section, four examples are given from previous research for thermal design using algorithmic design. The main distiction to be made between the former and latter two examples, is the methodology of design.

The first two examples illsutrate parametric methods which utilise generative systems using parametric models. The other two examples utilise performative algorithms and simulation programmes.


\section{Thermal Responsive Design using Generative Systems and Parametric Mapping}
\label{sec:zulas}
The following will showcase a number of experiments by Alejandro Zulas \cite{zulas04}, utilising scripting to create adaptable responsive enclosure systems with emphasis on sunlight incidence.

\subsection{Basic Responsive Algorithm: The Mutable Curtain}

The author attempted the design of a box capable of modulating light going through it (fig. \ref{fig:AZulasEncl}), which was done using Rhinoceros modelling program and its scripting language; \emph{Rhinoscript}. The experiment was an attempt to create an adaptive, responsive enclosure system which responded to solar incidence angles. 

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./Images/1-Enclosure}
\caption[Responsive Adaptable Enclosure Experiment]{The Enclosure and Results \cite{zulas04}}
\label{fig:AZulasEncl}
\end{figure}

The main variable in the experiment was the ratio of enclosure wall solid and void. Using an advanced draughting engine such Rhino and scripting language such as Rhinoscript, the researcher was able to create a responsive system with a generative random function to regulate the amount of light penetrating the enclosure.

\subsection{Interactive Parametric Modelling: Responsive Louvres System}

Another experiment by the same author \cite{zulas04} was done using a parametric design driven program called CATIA (Computer Aided Three-Dimensional Interactive Application). The objective of this exercise was also to modulate light at the enclosure level, but through shading. The researcher used a number of vertical and horizontal louvres which responded to two factors; the location of the sun throughout days of different seasons which would affect the arrangement of the louvres, in addition to the angle of incidence which affected the orientation of each louvre as to reflect the light in a direction away from the building. 

The parametric CAD program, CATIA; had some advantages over Rhino as it displayed the effect of any amendments to the script interactively in the form of graphical feedback, which was beneficial to the process. 

\subsection{Context Responsive Parametric Model: Adaptable Pavilion}
\label{sec:AdptPav}

Another experiment using CATIA; an attempt to design a temporary exhibition pavilion \cite{zulas04}. The exercise focuses on the conception of a contextual responsive building addressing different variations on the overall building form and envelope in relation to sunlight. 

\subsubsection{Design Intentions:} 

\begin{enumerate}
\item Generate an appropriate enclosed environment for the sculptures to be exhibited.
\item Implementation of a responsive louvre system as a filter to redirect light incidence inside the pavilion.
\item Analysing the behaviour of the building towards conceiving a sun responsive building. 
\end{enumerate}

The context consisted of the sun, the museum wall and trees defining the yard. The museum wall and the trees were defined as static elements of the context, while the sun was understood as a dynamic element; this was to be taken into consideration as input. The main variables taken into consideration were the pavilions shape, length, height, proportions\ldots etc. 

Object relations were programmed using conditional ``\emph{if : then \dots else : that}''. In other words; \emph{if} the location of the sun in relation to its day-path is ``\emph{n}'', \emph{then} the line defining the pavilion's profile gets increased or decreased or rotated or thickened\ldots etc, by a predefined ``\emph{n}'' factor. (Refer to fig. \ref{fig:MpRlt})

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./Images/5-MappingRelations}
\caption[Mapping Design Relations]{Mapping Relationships \cite{zulas04}}
\label{fig:MpRlt}
\end{figure}

The interactiveness of CATIA was quite notable when the author attempted to change the location of the sun by means of a graphical slider and witnessed real-time changes to building shape due to the change in solar location (fig. \ref{fig:IntActCAT})

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./Images/6-InteractiveCATIA}
\caption[Interactive Response]{Automated Adaption \cite{zulas04}}
\label{fig:IntActCAT}
\end{figure}

The end result was quite similar to the initial design intentions (fig. \ref{fig:FinalPav}).

\begin{sidewaysfigure}[htbp]
\centering
\includegraphics[width=19cm]{./Images/7-FinalPavilion}
\caption[Adaptable Pavilion Design Results]{The Adaptable Pavilion \cite{zulas04}}
\label{fig:FinalPav}
\end{sidewaysfigure}

\newpage
\subsection{Advanced Interrelations Mapping and Model Control Techniques: The Kendall Pavilion}
\label{sec:KendallPavilion}

The following is a comprehensive exercise to create an adaptable responsive system, with an approach combining the following concepts and control mechanisms:

\begin{enumerate}
\item Programming objects using Shape Grammar.
\item Conventional programming through coding or scripting.
\item Modelling a real-world situation corresponding to naturally occurring phenomena.
\end{enumerate}

The task is to design an architectural envelope capable of performing responsive geometrical reconfiguration based on the idea of adaption in relation to a geographical location, urban context, and to specific design intentions, responding to the designer's direct manipulation.

\subsubsection{The Urban Context Description}

The space designated to locate the pavilion is surrounded by and high and medium sized structures.

\subsubsection{The Design Intentions} 
\vspace{-0.3cm}
\begin{enumerate}
\item Generate an architectural skin.
\item Embed ``sensory intelligence'' into the building, providing it with object recognition capabilities (surrounding buildings and pedestrian paths) and sun location responsiveness.
\item Embed ``structural intelligence'' into the building skin system, recognising and fixing potential structural instabilities, due to the fact that the building will suffer geometrical reconfiguration while responding to stimulus.
\end{enumerate}
\vspace{-0.4cm}

\subsubsection{The Mapping Process}

As the building will be corresponding to different stimulus, the cause and effect sequence had to be programmed, and four elements were selected as inputs:
\vspace{-0.3cm}
\begin{itemize}[nolistsep]
\item Program
\item Context
\item Environment
\item Designer Input
\end{itemize}
\vspace{-0.4cm}
(See fig. \ref{fig:MapProcs})

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./Images/10-MapProcs}
\caption[Input/Output Mapping Process]{Input/Output Mapping Process \cite{zulas04}}
\label{fig:MapProcs}
\end{figure}

The author then continued to map the interrelationships of the architectural elements. This was due to the fact that each of the architectural elements would continue to affect each other in a continuous loop indirectly (fig. \ref{fig:ArchElmLoop}).

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./Images/11-ArchElmLoop}
\caption[Architectural Elements Interrelationships]{Architectural Elements Interrelationships \cite{zulas04}}
\label{fig:ArchElmLoop}
\end{figure}

\subsubsection{Control Mechanisms.}

Having defined the variables and mapping their interrelationships; the next step was to model the data and program the control algorithms. This process was inline with all the design intents mentioned earlier, namely: 
\begin{inparaenum}
\item ``embedding ``sensory intelligence'' in order to achieve object recognition. To be achieved through contextual based conditional,
\item embedding ``smart flexibility'' allowing the user to intervene directly and freely with virtual objects throughout the design process. Implementing the concept of stretchable surfaces (to be further explained),
\item embedding ``structural intelligence in order to achieve specific self-fixing capabilities. Introducing the concept of emergence, to be implemented locally through a rule based approach (to be further explained).''
\end{inparaenum} \cite{zulas04}

The computational approaches that were used to tackle the three concepts stated above were: 

\begin{enumerate}[nolistsep]
\item Parametric representation of context
\item Parametric delimited action: Semi-automated human intervention
\item Generative emergence rules
\end{enumerate}

\paragraph{Parametric representation of the context.}\mbox{}
In order for the system to be ``adaptive'' and ``responsive'', the context should be variable, and therefore parameterised. In the earlier work by the author (refer to section \ref{sec:AdptPav}) the stimulus to which the building had responded was the sun and its movement. Here however, the whole context of buildings, roads and the rest of the stimuli mentioned earlier will affect the buildings response (see fig. \ref{fig:ParametricKendallSq}).

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./Images/12-ParametricContext}
\caption[Parametric Context]{A plan view of the Kendall Square area being manipulated to generate different context through parametric controls \cite {zulas04}}
\label{fig:ParametricKendallSq}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=0.4\textwidth]{./Images/13-KendallIsometric}
\caption[Kendall Square Isometric]{An isometric of the Kendall Square \cite{zulas04}}
\label{fig:KendallIsom}
\end{figure}

The parameterisation of the context was achieved by applying a stretchable two-dimensional grid, or net, of lines on the surrounding buildings and pedestrian paths. The method is referred to by the author as manipulation through ``stretchable surfaces''.

\paragraph{Delimited Action: Semi-automated Human Intervention.}\mbox{}
The ``stretchable surfaces'' concept was further incorporated into the system by making adaption of the pavilion respond to any changes in the grid, which would act as a guide to the programmed adaption algorithm, while allowing direct adjustments to the grid by the designer; hence, a ``semi-automated'' human intervention.

\subparagraph{Generative Emergence Rules.} As mentioned earlier in this chapter; draughting and modelling programs usually provide generative modelling through scripting (end-user programming languages). In this case the author \cite{zulas04} utilised the scripting capabilities of CATIA (parametric modelling application). The emergence rule acts as a form of ``structural intelligence'' (a concept described earlier) where the rule identifies the length of two sides of the basic composition of the pavilion's main structure; which if they are exceeded the system will automatically add an emergent structural element to preserve structural integrity. The script used is shown in fig. \ref{fig:EmergRuleScr}.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.7\textwidth]{./Images/14-EmergRuleScr}
\caption[Emergence Rule Script]{A screen capture of the script used in CATIA to apply the emergence rule \cite{zulas04}}
\label{fig:EmergRuleScr}
\end{figure}

\section{Thermal Responsive Systems using Parametric Node-based Editors}
\label{sec:NodeBased}

The following experiments were done as part of the research by Huei Shenh Yi \cite{yi09}. The research utilised the programme: Grasshopper.

\paragraph{Grasshoper}\mbox{}

A program developed in 2009 as a parametric modelling plug-in for Rhino (3D modelling software): ``It is based on explicit history concept that recorded the modelling process, allowing users to manipulate graphic node\footnote{A node based editor passes data from component to component through links. The data is defined either in the plugin itself, or inputted externally} to generate parametric models. An advantage of Grasshopper is that users with little programming experience can manipulate graphic nodes to define relationships for each element to generate a parametric model''\cite{yi09}. Grasshopper also allows users to input scripts in VB.net, C\# and Python programming languages.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./Images/31-GrassGUI}
\caption[Grasshopper Node-based Editor]{Grasshopper Node-based Editor \cite{yi09}}
\label{fig:GrassGUI}
\end{figure}

\subsection{Responsive Louver System}

The author created a responsive louver system, which respnds to sunlight direction change. The system was developed from previously written algorithm in C\# called PSA, which controls the change of solar direction; and also of an algorithm developed by Ted Ngai (the reference directs the reader to his website: \url{tedngai.net}). The author modified the algorithm to enable 3D models to follow the orientation of the sun, and the colour of each louver blade to change according to its orientation with regards to the sun's position (see fig \ref{fig:RLS1}).

\begin{figure}[htbp]
\centering
\includegraphics[width=0.8\textwidth]{./Images/32-RLS1}
\caption[Responsive Louver System]{Responsive louver system \cite{yi09}}
\label{fig:RLS1}
\end{figure}

The data input interface allows the user to input the time (hour, day and month) and coordinates. The orientatio of the sun is then simulated based on the inputed data (see fig. \ref{fig:RLS2}).

\begin{figure}[htbp]
\centering
\includegraphics[width=0.8\textwidth]{./Images/33-RLS2}
\caption[RLS Data Input Interface]{RLS Data Input Interface \cite{yi09}}
\label{fig:RLS2}
\end{figure}

The algorithm creates the initial population for each louver to transform the direction in order to evaluate and the optimised relationship between sunlight and each louver blade (see fig. \ref{fig:RLS3}).

\begin{sidewaysfigure}[htbp]
\centering
\includegraphics[width=20cm]{./Images/34-RLS3}
\caption[Responsive Louver System Node Editor and Model]{Responsive Louver System Node Editor and Model \cite{yi09}}
\label{fig:RLS3}
\end{sidewaysfigure}

\subsection{Responsive Bricks System}

Another system which was created using Grasshopper, which generates a building envelope a with a hollow brick like arrangement, and manipulates the size of the voids in the bricks in accordance with sunlight direction. The input and manipulation method is same as the previous example (see fig. \ref{fig:RBS}).

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./Images/35-RBS}
\caption[Responsive Brick System]{Responsive Brick System \cite{yi09}}
\label{fig:RBS}
\end{figure}
 
\clearpage
\section{Optimisation using Performative Algorithm and Simulation of Internal Space Heat Gain}
\label{sec:GSM}

The following experiment is part of the research done by Luisa Gama Caldas \cite{caldas01}, in the efforts to create what was called a ``Generative System'', consisting of two main components: \begin{inparaenum} \item a search and optimisation module, and \item a simulation module \end{inparaenum}.

The author chose Genetic Algorithm---abbreviated: GA---(see sec. \ref{subsec:GA}) for the search and optimisation module, which feeds the initial input along with building parameters into the simulation program DOE (see sec. \ref{par:DOE}) which evaluates the results and returns its fitness function value (in this case the annual energy consumption of a building) into GA, which in turn searches the solution space until it reaches the last population\footnote{For explanation of GA terminology; refer to section \ref{subsec:GA}}, the results are then inspected using a visualisation program (see fig \ref{fig:GSfitFun}).

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./Images/15-FitnessFunction}
\caption[GS Information Flow]{The flow of information across the Generative System components \cite{caldas01}}
\label{fig:GSfitFun}
\end{figure}

\subsection{The Simulation Module}
DOE2.1E was chosen as the simulation module for its capability to perform thermal calculations, namely: thermal loads, HVAC loads, extensive material modelling capabilities, library of HVAC systems, and also for its accuracy and reasonable computation times. However, DOE2.1E is incapable of other thermal design related calculations such as Computational Fluid Dynamics [CFD] which simulates air movement and its thermal effects. Another missing feature in DOE is the capability to calculate and predict thermal comfort. 

The author performing the experiment had recommended Energy Plus (see sec. \ref{par:EnergyPlus}) as a replacement of DOE for the above mentioned reasons---in addition to others--- which was not used as it was not available at the time when the experiment was performed.

In the context of this thesis however, the aspects of air movement and ventilation have been disregarded for the sake of simplicity of illustration of generative systems and thermal design integration, and therefore, the simulation of static thermal properties of buildings will suffice in this example.

\subsection{The Search Module}

\label{subsec:GA2}
Genetic Algorithm had been chosen by the author as the search and optimisation module due to that GA provides a final `population' of solutions, not a single solution. As stated by the author: ``\emph{A system that would provide a single `optimised' solution might have poor acceptance among architects, who might prefer to have a range of choices between different solutions, all having a high standard of performance according the objective functions included in the search, and from where the architect could exert further choice, according to other criteria like personal preference, initial design intention \ldots etc}.'' (refer to sec. \ref{subsec:OptimComp} for comparison between GA and other search and optimisation methods by Caldas \cite{caldas01}).

Another advantage of GA is the coding of variables in the search process, which applies to binary GA's using binary code---1's and 0's---in its chromosomes. The chromosomes can be encoded into any kind of variable, numerical or non-numerical; for example, part of the chromosome can be encoded as a material name, or a dimension, or into any other kind of numerical or non-numerical variable.

This section will expand on the discussion of GA basic operators: reproduction, crossover and mutation (see sec. \ref{subsec:GA}). The most common implementation of reproduction is called \emph{The Biased Roulette Wheel}, where each current string in the population has a roulette wheel slot sized in proportion to its fitness; that means that the probability of a given individual being selected for reproduction is proportional to its fitness:

\begin{equation}
P(x)=f(x)/ \sum\limits_{j=1}^n f(j) 
\label{eqn:BiasedRoulette}
\end{equation}
\small Where $n=$ number of individuals in the generation
\normalsize

This method of selection and reproduction is usually combined with other methods to determine which individuals will pass to the next generation, such as \emph{Deterministic Tournament Selection}, where two randomly selected strings are set against each other, and only the one with the highest fitness moves to the next generation.

Other notable reproduction methods include: \emph{Multi-Parent Reproduction, Parallel Steady-State Reproduction,} and \emph{Gradient-like Reproduction}.

After reproduction, comes Crossover, which is responsible for diversification during the search process, and is the most prominent operator in GA. During crossover, parts of randomly selected chromosomes are swapped to create a new individual (refer to table \ref{CRSOVR}). Only an elite solution\footnote{A solution with the highest fitness value of the current generation} is passed to the next generation without crossover. The purpose of crossover is to create new points in the solution space through interchange of information between different solutions, which is vital to the success of the search as the elimination of solutions from the limited initial population must be regenerated, and to create diverse generations, expanding the sample space, and increasing the chance of finding the global optimum\footnote{The solution with the highest fitness function value in the entire solution space, as opposed to \emph{Local Optimum} which is the fittest only in the current population}.

Crossover types include \emph{one-point, two-point} and \emph{uniform} crossover; the difference being---respectively---whether the algorithm assigns one crossover point, two crossover points or substitutes the whole string in the following manner:

\begin{equation}
Z=(z_1,\cdots,z_n), z_i=x_i \text{or} z_i=y_i
\label{eqn:UniformCross}
\end{equation}
\small Where $n$ is the chromosome length
\normalsize

Mutation involves changing an \emph{allele}\footnote{One digit of the chromosome string} with a given probability to look for new points in the solution space. Mutation is responsible for introducing information that did not exist in the initial population. Caldas \cite{caldas01} mentions a rule of thumb based on parametric studies, which states that a mutation rate of $m=1/n$, where $n$ is the size of the chromosome; is almost optimal.

\subsection{Previous Attempts of Optimisation through Building Energy Simulation Programs}

The researcher continues to illustrate previous work done prior to her research, with the attempt to apply energy simulation programs to create optimum solutions. One of the attempts include the use of DOE-2.1E to optimise design parameters of a window, which relies on indices and weight factors creating a single figure by which the design is evaluated. The indices were: \begin{inparaenum} \item fuel usage, \item electricity usage, \item peak electricity demand, \item thermal comfort, and \item visual comfort \end{inparaenum}. The idea of combining the five indices into one figure however was deemed dubious by the researcher. Thermal comfort was calculated as a correlation between magnitude of solar radiation and the percentage of dissatisfied people. Visual comfort was done through calculation of the glare index.

\subsection{Building the Generative System}

The method used by the researcher was to link Genetic Algorithm and DOE-2.1E, where GA would call DOE-2.1E whenever calculation of the fitness of an individual is needed; the fitness function being the \textbf{annual energy consumption}. DOE-2.1E would then run a thermal and lighting simulation of the building under study with the parameters determined by the individual chromosome of that solution. 

A method of data exchange between GA and DOE was developed; different procedures were used for numerical variables, such as dimensions or coordinated, in addition to non-numerical variables.

Non-numerical variables such as material names encoding design was handled with special attention to the relation between the material properties and the binary code. For example; if the number of material selections was 16, 4 alleles would be used ($2^4=16$), so that a material designation would be something like 0101. Each of the 4 alleles would have a specific designation; for example, the first digit would designate if it's an insulation material, the second would designate high or low conductivity \ldots\hspace{0cm}etc.

Another problem was how to incorporate architectural language into the algorithm. Although DOE uses what is called \emph{The Building Description Language} (BDL) as an input format to describe building geometry, it does not allow incorporation of information describing the relations between the different variables under study. Therefore, the constraints of architectural design had to be encoded inside GA code.

\subsection{Input and Output Formats}

Since GA had no designed user interface, the input process was text-based. Input consisted of two main steps; namely, creating a DOE-2.1E input file describing the building---including geometry, orientation, space layout, construction material \ldots\hspace{0cm}etc.---and also providing information on electrical and mechanical systems to be used in schedules. This was created with nil values assigned to the different variables under study, which would be created by the algorithm. Each of the variables is represented by a numerical value.

The second step would be to adapt the GA to the problem under study, as well as the input files it reads during execution. A function in the source code would call DOE, and pass the right number of arguments to it in correct order. Some relations between different variables are specified. 

Finally, the input files GA reads are modified to identify the variables to be considered in the search, the upper and lower boundaries of each variable, the number of intermediate steps between those limits and the number of binary bits required to code each variable. Also, a file would be included that defines the population size in GA, and the number of generations, in addition to other control mechanisms of the search process.

The output is then passed on to either an AutoLisp routine which draws an AutoCAD file from the results, or through a program called DrawBDL which generates a 3D model from DOE output files.

\subsection{Testing the Generative System}

For the experiment, a simple schematic building consisting of a core area with surrounding rooms facing each of the four main cardinal orientations\footnote{North, South, East and West}; each room had a single window looking on the opposite side of the core (see fig. \ref{fig:SchmBuild}).

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./Images/16-SchematicBuilding}
\caption[GS Schematic Building]{GS Schematic Building \cite{caldas01}}
\label{fig:SchmBuild}
\end{figure}

\paragraph{Simulation Method}\mbox{}

A framework is designed for the genetic algorithm to allow for encoding and manipulation of variables which suits the problem. To be able to utilise GA; it was necessary to provide the following:
\begin{enumerate}[nolistsep]
\item A binary string of bits
\item An objective function definition, which would pass the data to DOE
\item Mechanisms for selection, crossover and mutation
\item Choosing initial population size, and
\item Maximum number of generations.
\end{enumerate}

\subparagraph{Representation of feasible solutions.}\mbox{}

The building has four different types of windows, one for each orientation. The windows were defined by two dimensions: width and height. Each dimension would vary from 0.3 to 2.4 metres in discrete steps of 0.3 metres; thus resulting in a total of 8 possible values. In order to code 8 values in binary code, only 3 bits are needed [$2^3=8$]. A single dimension therefore can be coded as follows:

\begin{table}[h]
\centering
\begin{tabular}{l|rrrrrrrr}
\textbf{Decoded Numerical Value(m)}&0.3&0.6&0.9&1.2&1.5&1.8&2.1&2.4\\ \hline
\textbf{Binary Code}&000&001&010&011&100&101&110&111\\
\end{tabular}
\caption{Window Dimension Binary Coding}
\label{table:WinDimCode}
\end{table}

Having encoded the 8 steps for each dimension, the 8 dimension [2 dimensions $\times$ 8 orientations] would need 24 bit strings [3 bits per variable $\times$ 8 variables]. A valid chromosome in this case would be:\\
\vspace{0.3cm}
\begin{center}
\textbf{010111001011100110001110}
\end{center}

\subparagraph{Objective Function}\mbox{}

The objective function value is the result of running thermal and lighting simulation with the window parameters chosen, and expresses the total annual energy consumption in the building in MWh\footnote{Mega-Watt-hour}, taken from the \emph{Building Energy Performance Summary} (BEPS) report of DOE-2.1E.

\subparagraph{Selection Mechanism}\mbox{}

Biased Roulette Wheel selection was used (refer to page \pageref{eqn:BiasedRoulette}).

\subparagraph{Crossover Mechanism}\mbox{}

Uniform crossover was used (refer to page \pageref{eqn:UniformCross}). The probability of crossover was set to 1, to ensure a high recombination rate.

\subparagraph{Mutation Mechanism}\mbox{}

Mutation was set to 0, due to the small initial population, large number of generations and high crossover rate, which renders it unnecessary.

\subparagraph{Population Size and Number of Maximum Generations}\mbox{}

A small initial population size was chosen [$n=5$], and number of generations was set to 100 (extending the number to 200 and 300 had been tested, but did not cause no improvement to the final solution).

\paragraph{Problem Description, Simulation Method and Testing}\mbox{}

The problem in this case is sizing the windows to optimise lighting, heating and cooling performance. Daylight levels are simulated and measured at two referenced points inside each space, for each hour of the year. The results are compared to the required illuminance levels, and the amount of additional artificial lighting (assumed as continually dimmable) is calculated, and quantified for energy consumption. The heat load of artificial lighting is also added.

Internal temperatures are then calculated, taking into account the external climate, characteristics of building fabric (see sec. \ref{ThermDesVar}), solar gains through windows, internal gains from occupants, equipment and artificial lighting \ldots\hspace{0cm}etc. The results are compared to required levels, resultant HVAC loads are calculated and quantified as energy consumption. 

\paragraph{Determining Solution Spaces for a Selected Climate}\mbox{}

Before considering any solutions given by the Generative System, the algorithm must first be tested against an example of limited size of which the optimal solution is predeterminately known, to determine whether it would find optimal solutions for this problem. This was done by creating a solution space of 64 points for one orientation fixing the window size variables to only one value for the other orientations. The GA was run for 100 generations for each orientation.

The solution space for a selected climate (Phoenix, Arizona) was then plotted graphically and the Generative System results were compared against the visible local minima and global minimum of each orientation (see figures \ref{fig:GSTestRun:W}, \ref{fig:GSTestRun:N}, \ref{fig:GSTestRun:E}, \ref{fig:GSTestRun:S})

\begin{figure}[htbp]
\centering
	\subfloat[Western Facade]{\includegraphics[width=0.45\textwidth]{./Images/17-WestWindow}\label{fig:GSTestRun:W}}
	\hspace{1cm}
	\subfloat[Northern Facade]{\includegraphics[width=0.45\textwidth]{./Images/18-NorthWindow}\label{fig:GSTestRun:N}}
	\vspace{1cm}
	\subfloat[Eastern Facade]{\includegraphics[width=0.45\textwidth]{./Images/19-EastWindow}\label{fig:GSTestRun:E}}
	\hspace{0.5cm}
	\subfloat[Southern Facade]{\includegraphics[width=0.5\textwidth]{./Images/20-SouthWindow}\label{fig:GSTestRun:S}}
\caption[Generative System Solution Space Test]{Generative System Solution Space Test for each facade \cite{caldas01}}
\end{figure}

The author then observed the local minima selected by the GS, and at which generation the search found the global minimum. Generally speaking; the faster the algorithm finds the global minimum the better. In cases where the global minimum was not found, the test proved that points very close to the global minimum were selected.

\paragraph{Assessing GS Performance in a Larger Solution Space}\mbox{}

Since the first test proved successful, providing enough confidence in the results to extend the method to larger problems for which the solution space cannot be calculated manually. The GS was used to search the solution space of window sizes for all orientations simultaneously, which would result in a solution space of more than 16 million points.

The experiment was done five times, each running for 100 generations. The initial results showed high variance in the design patterns, progressively converging in the optimised solutions in the final generations (see figures \ref{fig:GSPhoenix:Initial} and \ref{fig:GSPhoenix:Final}).
\label{sec:GAConvergence}

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./Images/23-Gen10-80}
\caption[GA Generations Evolution]{Evolution of generations from 10 to 80 of one experiment \cite{caldas01}}
\label{fig:GenEvol}
\end{figure}

\begin{table}[h]
\centering
\begin{tabular}{|p{1.5cm}|p{6cm}|p{2cm}|p{2.2cm}|}
\hline
\textbf{Exper-\newline iment}&\textbf{Best Solution Found}&\textbf{Objective Function Value (MWh)}&\textbf{Percentage Above Minimum (\%)}\\ \hline
1&2.1/2.1/1.2/1.5/1.2/1.5/1.2/0.9&114.74&0.018\\ \hline
2&2.4/2.1/2.1/0.9/2.1/0.9/0.9/1.5&114.65&0.01\\ \hline
3&2.1/2.1/1.2/1.5/2.1/0.9/1.5/0.9&114.60&0.006\\ \hline
4&1.8/2.1/1.2/1.8/0.9/1.5/1.2/0.9&114.89&0.03\\ \hline
5&2.4/2.1/2.1/0.9/1.2/1.5/1.5/0.9&114.65&0.01\\ \hline
\end{tabular}
\label{tab:PhoenixSolutions}
\caption[Solutions for the Phoenix Climate]{Solutions for the Phoenix Climate \cite{caldas01}}
\end{table}

\clearpage

\section{Optimisation using Performative Algorithm, Simulation and Prioritised Reference Points}
\label{sec:RFDS}

This section illustrates the research and experimentation done by Go Kawakita \cite{kawakita08} to create a ``Responsive Fa\c{c}ade Design System'' or RFDS, which optimises window arrangement with respect to natural daylight level. Simulation of the model, and optimum solution search are executed within \textsc{ecotect}. The search algorithm chosen was Genetic Algorithm.

\subsection{Description of RFDS}

Responsive Fa\c{c}ade Design System is an automated window generation tool, which considers natural daylight levels at user defined reference points within a given space. As mentioned earlier; the system uses Genetic Algorithm (refer to sections \ref{subsec:GA} and \ref{subsec:GA2} on GA)for optimum solution search, and \textsc{ecotect} for environmental simulation (refer to page \pageref{par:ECOTECT} for more information on \textsc{ecotect}). The system (RFDS) utilises \emph{Lua}, a simple programming language; as the scripting language within \textsc{ecotect}, which is the means by which the Genetic Algorithm is inputed.

\subsection{Genetic Algorithm Implementation}

The author explains the sequence within Genetic Algorithm as implemented in his research (refer to fig. \ref{fig:GoGAFC}) as follows:

\begin{figure}[htbp]
\centering
\includegraphics[height=13.5cm]{./Images/24-GoGALoop}
\caption[GA Flow Chart]{GA Flow Chart \cite{kawakita08}}
\label{fig:GoGAFC}
\end{figure}

\paragraph{Initialisation}\mbox{}

In this step; parameters such as population size, number of generations and chromosome length are inputted. The author explaings that longer chromosomes need larger initial populations, and that smaller populations tend to converge prematurely.

\paragraph{Evaluation}\mbox{}

The chromosomes are evaluated according to the fitness function.

\paragraph{Selection}\mbox{}

Fitter chromosomes are selected for reproduction, the better the evaluation of each chromosome; the higher the probability of selection. RFDS uses a combination of elite selection\footnote{Elite Selection: the fittest chromosomes are selected in order; no probability is used} and roulette selection.

\paragraph{Crossover}\mbox{}

Crossover is implemented to introduce variation in the population.

\paragraph{Mutation}\mbox{}

Mutation is implemented to introduce diversification and decrease the possibility of premature convergance\footnote{Convergence: The narrowing down of results to those nearest to the optimum solution (refer to page \pageref{sec:GAConvergence})}. The mutation rate used is 1/L, where L is the length of the chromosome.

\paragraph{Terminal Criterion}\mbox{}

Conditions are given and evaluated to determine when the GA is to be terminated. The output of the generation is then selected as possible optimum solutions. Possible conditions include:

\begin{enumerate}
\item If the fittest score in the population satisfies the certain target: \emph{Star Gene}
\item If the average fittness score in the population satisfies the certain target: \emph{Population Improvement}
\item If the increase or decrease of fitness score in the population becomes below a certain value: \emph{Convergence}
\item If the number of generations becomes over the defined value: \emph{Finite Iteration} 
\end{enumerate}

\subsection{RFDS Implementation and Testing}

A space is created, which is represented by a cuboidal geometry, and a number of windows are arranged on the envelope, with reference points at which natural daylight levels are measured. The user inputs two parameters at the beginning of the optimisation process; target daylight levels at each reference point, and the priority of each target. The terminal critrion in RFDS is the number of generations. A detailed illustration of the process is shown in figure \ref{kawakitaGA}. The explanation of each element of the system is as follows:

\begin{figure}[hbtp]
\centering
\includegraphics[width=\textwidth]{../Chapter3/Images/16-kawakitaGA}
\caption[RFDS GA Process Flow Chart]{RFDS GA Process Flow Chart \cite{kawakita08}}
\label{kawakitaGA}
\end{figure}


\paragraph{Reference Points}\mbox{}

Reference points are placed by the user anywhere within the space. For example, the reference points could be placed at the points where light levels are the most important such as desks or reading areas.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{./Images/25-RefPoints}
\caption[RFDS Reference Points]{RFDS Reference Points \cite{kawakita08}}
\label{fig:RFDSRefPoints}
\end{figure}

\paragraph{Target Daylight Level [lux]}\mbox{}

The fitness scores are calculated in terms of target daylight levels determined by users.

\paragraph{Priority Level of Targets}\mbox{}

Priority levels influence fitness measurements as well as target daylight levels. Priorities are categorized into three levels: high, normal and low. This is considered a weighing system which affects the selection of possible optimum solutions.

\paragraph{Window Size and Interval}\mbox{}

Windows are arranged in lines as shown in figure \ref{fig:RFDSWin}. The windows are pixel-like, with their size and interval adjustable by the user.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{./Images/26-RFDSWindows}
\caption[RFDS Window Arrangement]{RFDS Window Arrangement \cite{kawakita08}}
\label{fig:RFDSWin}
\end{figure}

\paragraph{GA Operators and Initial Inputs}\mbox{}

In the GA of RFDS the operators are set as follows:

\begin{enumerate}[nolistsep]
\item Selection: Elite and Roulette selection are combined
\item Crossover: Uniform Crossover is utilised (refer to eqn. \ref{eqn:UniformCross})
\item Mutation: A mutation rate of 1/L was used (L= Chromosome Length)
\end{enumerate}

\begin{figure}[hbtp]
\centering
\includegraphics[width=\textwidth]{../Chapter3/Images/17-kawakitaChromo}
\caption[Chromosome Coding]{Coding of fenestration variables in GA chromosomes \cite{kawakita08}}
\label{kawakitaChromo}
\end{figure}

\subsubsection{Fitness Function}

The system is an optimisation tool considering daylight levels; therefore, in the case of RFDS, the chromosome of minimum differences from target levels is the fittest. A weighing factor is also utilised in this model, which represent the priorities of each reference point. The fitness function is the sum of all weighted differences (differences multiplied by their weight factor). The aim of the experiment is therefore for the fitness score to reach zero.

\subsubsection{Optimisation with User-defined Priority Levels}

The GA parameters are:
\begin{enumerate}[nolistsep]
\item Population size = 20 
\item Number of generations = 400
\item Number of individuals for elite selection = 2
\item Mutation rate = 0.03
\end{enumerate}

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./Images/27-RFDSimplement}
\caption[RFDS Space Dimensions and Window Size]{Space dimensions and windows size \cite{kawakita01}}
\label{fig:RFDSimplement}
\end{figure}

The dimensions of the tested space and windows size are illustrated in figure \ref{fig:RFDSimplement}. Target lighting levels and weighting factors are illustrated in figure \ref{fig:RFDSpriorities}.

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./Images/28-RFDSpriorities}
\caption[RFDS Target Light Levels]{Target light levels and weight factors \cite{kawakita01}}
\label{fig:RFDSpriorities}
\end{figure}

\subsubsection{Optimisation Results}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./Images/29-RFDSfitnessscores}
\caption[RFDS Fitness Scores]{Fitness scores across generations \cite{kawakita01}}
\label{fig:RFDSfitness}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./Images/30-RFDSdiff}
\caption[RFDS Target Level Differences]{Differences from target levels from generation 0 to 150 \cite{kawakita01}}
\label{fig:RFDSdiff}
\end{figure}

\clearpage
\section{Conclusions}

In this chapter, two methodologies of thermal design using algorithm have been illustrated. The first used Generative algorithm (sections \ref{sec:zulas} and \ref{sec:NodeBased}), the second utilised Optimisation / Performative algorithm (section \ref{sec:GSM} and \ref{sec:RFDS}).

In the case of the Generative approach, the following can be deducted:
\begin{enumerate}
	\item The use of Generative algorithm relies purely on the parametrisation of the model, and the mapping of relationships between the different parameter that generates or transforms the building geometry.
	\item This approach is much easier to control; however, it cannot find the best solution, and is very limited in creating new forms that can still be thermally efficient since it is driven by Generative algorithm, not by building performance (\emph{i.e.} building performance is the by-product, not the main driving force).
\end{enumerate}

In the case of Optimisation approach, the following can be deducted:
\begin{enumerate}
	\item This method relies on the loop between optimisation algorithms and simulation programmes, to continually measure the performance and accordingly modify the building envelope form.
	\item An important part of the process is choosing the right tools; choosing the best algorithm for the specific case, and choosing the right simulation programme. Also, the technicalities of programming and linking the simulation results with the algorithm are crucial.
	\item This approach is driven by the search for optimum building performance, and therefore it is much more capable of finding a highly thermally efficient design in a minimal duration of time.
	\item As seen in section \ref{sec:GSM}; it is also helpful to test the algorithm on a small predefined solution space, to see if the algorithm can find the global optimum.
	\item The methods of measurement varied from analysis of internal space heat gain, to measurement of specific reference points with assigned weights (priorities).
\end{enumerate}
